#!/usr/bin/env python3
"""Direct Tracker Upload Integration"""

from pathlib import Path
from typing import Optional, Dict, Any, List
from abc import ABC, abstractmethod
import requests
from urllib.parse import urlparse
import time

from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn

console = Console()

class BaseTrackerUploader(ABC):
    """Abstract base class for tracker uploaders"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'qBittorrent-TorrentCreator/2.0'
        })

    @abstractmethod
    def upload_torrent(self, torrent_path: Path, metadata: Dict[str, Any]) -> bool:
        """Upload torrent to tracker"""
        pass

    @abstractmethod
    def get_tracker_name(self) -> str:
        """Get human-readable tracker name"""
        pass

    def _get_credential(self, key_type: str) -> Optional[str]:
        """Get tracker-specific credential from secure storage"""
        try:
            from secure_credentials import get_secure_tracker_credential
            tracker_name = self.get_tracker_name().lower()
            return get_secure_tracker_credential(tracker_name, key_type)
        except ImportError:
            return None

    def _handle_response(self, response: requests.Response) -> bool:
        """Handle upload response with proper error handling"""
        tracker_name = self.get_tracker_name()

        if response.status_code == 200:
            # Check if response contains success indicators
            response_text = response.text.lower()
            if any(word in response_text for word in ['success', 'uploaded', 'ok']):
                console.print(f"[green]✅ Successfully uploaded to {tracker_name}[/green]")
                return True
            else:
                console.print(f"[yellow]⚠️ Upload to {tracker_name} may have succeeded (unclear response)[/yellow]")
                return True
        else:
            console.print(f"[red]❌ Upload to {tracker_name} failed: HTTP {response.status_code}[/red]")
            if response.text:
                console.print(f"[dim]Response: {response.text[:200]}...[/dim]")
            return False

class RedactedUploader(BaseTrackerUploader):
    """Upload to RED (Redacted) tracker"""

    def get_tracker_name(self) -> str:
        return "RED"

    def upload_torrent(self, torrent_path: Path, metadata: Dict[str, Any]) -> bool:
        """Upload to RED tracker"""
        api_url = "https://redacted.sh/ajax.php?action=upload"

        # Get secure API key
        api_key = self._get_credential("api_key")
        if not api_key:
            console.print("[red]❌ No API key found for RED tracker[/red]")
            console.print("[dim]Run: python -m secure_credentials setup-tracker red api_key[/dim]")
            return False

        headers = {"Authorization": f"token {api_key}"}

        # Prepare metadata
        data = {
            'type': metadata.get('category', '0'),
            'title': metadata.get('title', ''),
            'year': metadata.get('year', ''),
            'format': metadata.get('format', ''),
            'bitrate': metadata.get('bitrate', ''),
            'media': metadata.get('media', ''),
            'tags': metadata.get('tags', ''),
            'desc': metadata.get('description', ''),
        }

        try:
            with open(torrent_path, 'rb') as f:
                files = {'file_input': f}
                response = self.session.post(api_url, headers=headers, files=files, data=data, timeout=30)
                return self._handle_response(response)
        except requests.exceptions.RequestException as e:
            console.print(f"[red]❌ Network error uploading to RED: {e}[/red]")
            return False

class OrpheusUploader(BaseTrackerUploader):
    """Upload to OPS (Orpheus) tracker"""

    def get_tracker_name(self) -> str:
        return "OPS"

    def upload_torrent(self, torrent_path: Path, metadata: Dict[str, Any]) -> bool:
        """Upload to OPS tracker"""
        # OPS API endpoint (placeholder - needs actual endpoint)
        api_url = "https://orpheus.network/ajax.php?action=upload"

        api_key = self._get_credential("api_key")
        if not api_key:
            console.print("[red]❌ No API key found for OPS tracker[/red]")
            return False

        headers = {"Authorization": f"token {api_key}"}

        # OPS-specific metadata mapping
        data = {
            'type': metadata.get('category', '0'),
            'title': metadata.get('title', ''),
            'year': metadata.get('year', ''),
            'format': metadata.get('format', ''),
            'bitrate': metadata.get('bitrate', ''),
            'media': metadata.get('media', ''),
            'tags': metadata.get('tags', ''),
            'desc': metadata.get('description', ''),
        }

        try:
            with open(torrent_path, 'rb') as f:
                files = {'file_input': f}
                response = self.session.post(api_url, headers=headers, files=files, data=data, timeout=30)
                return self._handle_response(response)
        except requests.exceptions.RequestException as e:
            console.print(f"[red]❌ Network error uploading to OPS: {e}[/red]")
            return False

class BTNUploader(BaseTrackerUploader):
    """Upload to BTN (BroadcastTheNet) tracker"""

    def get_tracker_name(self) -> str:
        return "BTN"

    def upload_torrent(self, torrent_path: Path, metadata: Dict[str, Any]) -> bool:
        """Upload to BTN tracker"""
        # BTN API endpoint (placeholder - needs actual endpoint)
        api_url = "https://broadcasthe.net/upload.php"

        api_key = self._get_credential("api_key")
        if not api_key:
            console.print("[red]❌ No API key found for BTN tracker[/red]")
            return False

        headers = {"Authorization": f"token {api_key}"}

        # BTN-specific metadata mapping
        data = {
            'type': metadata.get('category', '0'),
            'title': metadata.get('title', ''),
            'year': metadata.get('year', ''),
            'format': metadata.get('format', ''),
            'bitrate': metadata.get('bitrate', ''),
            'media': metadata.get('media', ''),
            'tags': metadata.get('tags', ''),
            'desc': metadata.get('description', ''),
        }

        try:
            with open(torrent_path, 'rb') as f:
                files = {'torrent': f}
                response = self.session.post(api_url, headers=headers, files=files, data=data, timeout=30)
                return self._handle_response(response)
        except requests.exceptions.RequestException as e:
            console.print(f"[red]❌ Network error uploading to BTN: {e}[/red]")
            return False

class UploadManager:
    """Main upload manager coordinating uploads to multiple trackers"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.uploaders = {
            'red': RedactedUploader(config),
            'orpheus': OrpheusUploader(config),
            'btn': BTNUploader(config)
        }

    def upload_to_tracker(self, torrent_path: Path, tracker: str, metadata: Dict[str, Any]) -> bool:
        """Upload torrent to a specific tracker"""
        tracker_lower = tracker.lower()

        if tracker_lower in self.uploaders:
            uploader = self.uploaders[tracker_lower]
            return uploader.upload_torrent(torrent_path, metadata)
        else:
            console.print(f"[yellow]⚠️ Upload to {tracker} not supported yet[/yellow]")
            return False

    def upload_to_multiple_trackers(self, torrent_path: Path, trackers: List[str],
                                   metadata: Dict[str, Any]) -> Dict[str, bool]:
        """Upload torrent to multiple trackers"""
        results = {}

        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=console
        ) as progress:

            main_task = progress.add_task("Starting uploads...", total=len(trackers))

            for tracker in trackers:
                progress.update(main_task, description=f"Uploading to {tracker}...")
                success = self.upload_to_tracker(torrent_path, tracker, metadata)
                results[tracker] = success
                progress.advance(main_task)

        # Summary
        successful = sum(1 for result in results.values() if result)
        total = len(results)

        if successful == total:
            console.print(f"[green]🎉 All uploads successful ({successful}/{total})[/green]")
        elif successful > 0:
            console.print(f"[yellow]⚠️ Partial success: {successful}/{total} uploads completed[/yellow]")
        else:
            console.print(f"[red]❌ All uploads failed ({successful}/{total})[/red]")

        return results

    def get_supported_trackers(self) -> List[str]:
        """Get list of supported trackers"""
        return list(self.uploaders.keys())
    """Handle uploads to various private trackers"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.session = requests.Session()
        # Load secure credentials
        self._load_credentials()

    def _load_credentials(self):
        """Load tracker credentials from secure storage"""
        try:
            from secure_credentials import get_secure_qbittorrent_password
            # This would be extended to support tracker-specific credentials
            pass
        except ImportError:
            console.print("[yellow]Secure storage not available for tracker credentials[/yellow]")

    def upload_to_redacted(self, torrent_path: Path, metadata: Dict[str, Any]) -> bool:
        """Upload to RED (Redacted) tracker"""
        # RED API endpoint
        api_url = "https://redacted.sh/ajax.php?action=upload"

        # Get secure API key
        api_key = self._get_tracker_credential("redacted", "api_key")
        if not api_key:
            console.print("[red]No API key found for RED tracker[/red]")
            return False

        headers = {"Authorization": api_key}

        with open(torrent_path, 'rb') as f:
            files = {'file_input': f}
            data = {
                'type': metadata.get('category', '0'),
                'title': metadata.get('title', ''),
                'year': metadata.get('year', ''),
                'format': metadata.get('format', ''),
                'bitrate': metadata.get('bitrate', ''),
                'media': metadata.get('media', ''),
                'tags': metadata.get('tags', ''),
                'desc': metadata.get('description', ''),
            }

            response = self.session.post(api_url, headers=headers, files=files, data=data)
            return self._handle_response(response, "RED")

    def upload_to_ops(self, torrent_path: Path, metadata: Dict[str, Any]) -> bool:
        """Upload to OPS (Orpheus) tracker"""
        # OPS upload logic here
        console.print("[cyan]OPS upload not yet implemented[/cyan]")
        return False

    def upload_to_btn(self, torrent_path: Path, metadata: Dict[str, Any]) -> bool:
        """Upload to BTN (BroadcastTheNet) tracker"""
        # BTN upload logic here
        console.print("[cyan]BTN upload not yet implemented[/cyan]")
        return False

    def _get_tracker_credential(self, tracker: str, key_type: str) -> Optional[str]:
        """Get tracker-specific credential from secure storage"""
        # This would integrate with secure_credentials.py
        # For now, return None to indicate not implemented
        return None

    def _handle_response(self, response: requests.Response, tracker: str) -> bool:
        """Handle upload response"""
        if response.status_code == 200:
            console.print(f"[green]✅ Successfully uploaded to {tracker}[/green]")
            return True
        else:
            console.print(f"[red]❌ Upload to {tracker} failed: {response.text}[/red]")
            return False

class TorrentUploadManager:
    """Manage torrent uploads to multiple trackers"""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.uploader = TrackerUploader(config)

    def upload_torrent(self, torrent_path: Path, trackers: List[str], metadata: Dict[str, Any]) -> Dict[str, bool]:
        """Upload torrent to specified trackers"""
        results = {}

        for tracker in trackers:
            console.print(f"\n[cyan]Uploading to {tracker}...[/cyan]")

            if tracker.lower() in ['red', 'redacted']:
                results[tracker] = self.uploader.upload_to_redacted(torrent_path, metadata)
            elif tracker.lower() in ['ops', 'orpheus']:
                results[tracker] = self.uploader.upload_to_ops(torrent_path, metadata)
            elif tracker.lower() in ['btn', 'broadcastthenet']:
                results[tracker] = self.uploader.upload_to_btn(torrent_path, metadata)
            else:
                console.print(f"[yellow]⚠️ Upload to {tracker} not supported yet[/yellow]")
                results[tracker] = False

        return results

def get_torrent_from_qbittorrent(client, torrent_hash: str) -> Optional[bytes]:
    """Retrieve torrent file directly from qBittorrent (if supported)"""
    try:
        # This would be the ideal method if qBittorrent supports exporting existing torrents
        # For now, this is a placeholder for future API support
        console.print("[yellow]Direct torrent export from qBittorrent not yet supported[/yellow]")
        return None
    except Exception as e:
        console.print(f"[red]Error retrieving torrent from qBittorrent: {e}[/red]")
        return None

# Future enhancement functions for torrent_creator.py
def upload_torrent_enhancement(torrent_creator_instance, torrent_path: Path):
    """Future enhancement: Upload created torrent to trackers"""

    # Get metadata for upload
    metadata = {
        'title': torrent_path.stem,
        'category': torrent_creator_instance.category or '0',
        'tags': ','.join(torrent_creator_instance.tags) if torrent_creator_instance.tags else '',
        'description': f"Created with qBittorrent Torrent Creator v2.0",
        'source': torrent_creator_instance.source or '',
    }

    # Initialize upload manager
    upload_manager = TorrentUploadManager(torrent_creator_instance.config)

    # Upload to configured trackers
    if torrent_creator_instance.trackers:
        tracker_names = [urlparse(tracker).netloc for tracker in torrent_creator_instance.trackers]
        results = upload_manager.upload_torrent(torrent_path, tracker_names, metadata)

        # Report results
        successful = sum(1 for result in results.values() if result)
        console.print(f"\n[green]Upload complete: {successful}/{len(results)} successful[/green]")

    return True
