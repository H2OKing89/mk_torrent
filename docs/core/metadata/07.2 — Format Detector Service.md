# 7.2) Format Detector Service (`services/format_detector.py`)

## Overview

The Format Detector service provides comprehensive audio format detection and quality assessment. It gracefully handles environments with or without Mutagen, providing accurate format classification and encoding details.

## Features

### Audio Format Detection
- **Container formats**: MP3, FLAC, AAC, M4A, M4B, OGG, OPUS
- **Codec identification**: MP3, AAC-LC, AAC-HE, FLAC, Vorbis, Opus
- **Quality assessment**: Bitrate, sample rate, bit depth
- **File validation**: Structure integrity checks

### Encoding Classification
- **MP3 VBR buckets**: V0, V1, V2, V3, V4, V5
- **CBR detection**: Constant bitrate classification
- **Lossless flags**: FLAC, ALAC, WAV identification
- **Quality scoring**: Relative quality assessment

### Graceful Degradation
- **Mutagen optional**: Falls back to extension-based detection
- **Basic mapping**: File extension â†’ format hints
- **Conservative estimates**: Safe default values
- **Error tolerance**: Continues processing with partial data

## Interface

```python
class FormatDetector:
    def __init__(self, require_mutagen: bool = False):
        """
        Initialize format detector.

        Args:
            require_mutagen: Raise error if Mutagen unavailable
        """

    def detect_format(self, file_path: Path) -> FormatInfo:
        """
        Detect audio format and encoding details.

        Args:
            file_path: Path to audio file

        Returns:
            FormatInfo with detected details
        """

    def get_duration(self, file_path: Path) -> Optional[int]:
        """
        Get audio duration in seconds.

        Args:
            file_path: Path to audio file

        Returns:
            Duration in seconds, None if unavailable
        """
```

## Data Structures

### FormatInfo
```python
@dataclass
class FormatInfo:
    format: str = ""          # MP3, FLAC, AAC, etc.
    encoding: str = ""        # V0, CBR320, Lossless, etc.
    bitrate: Optional[int] = None      # Average bitrate (kbps)
    sample_rate: Optional[int] = None  # Sample rate (Hz)
    bit_depth: Optional[int] = None    # Bit depth (bits)
    channels: Optional[int] = None     # Channel count
    duration_sec: Optional[int] = None # Duration (seconds)
    is_lossless: bool = False         # Lossless flag
    is_vbr: bool = False             # Variable bitrate flag
    quality_score: float = 0.0       # 0.0-1.0 quality rating
    source: str = ""                 # "mutagen" or "extension"
```

## Implementation Details

### Mutagen Backend
```python
from mutagen import File as MutagenFile

def _detect_mutagen(self, file_path: Path) -> FormatInfo:
    """Primary detection using Mutagen."""
    try:
        audio = MutagenFile(file_path)
        if not audio:
            return self._fallback_detection(file_path)

        return FormatInfo(
            format=self._get_format(audio),
            encoding=self._get_encoding(audio),
            bitrate=getattr(audio.info, 'bitrate', None),
            sample_rate=getattr(audio.info, 'sample_rate', None),
            duration_sec=int(getattr(audio.info, 'length', 0)),
            is_lossless=self._is_lossless(audio),
            is_vbr=self._is_vbr(audio),
            quality_score=self._calculate_quality(audio),
            source="mutagen"
        )
    except Exception:
        return self._fallback_detection(file_path)
```

### Extension Fallback
```python
EXTENSION_MAP = {
    '.mp3': {'format': 'MP3', 'encoding': 'CBR', 'lossless': False},
    '.flac': {'format': 'FLAC', 'encoding': 'Lossless', 'lossless': True},
    '.m4a': {'format': 'AAC', 'encoding': 'VBR', 'lossless': False},
    '.m4b': {'format': 'AAC', 'encoding': 'VBR', 'lossless': False},
    '.ogg': {'format': 'Vorbis', 'encoding': 'VBR', 'lossless': False},
    '.opus': {'format': 'Opus', 'encoding': 'VBR', 'lossless': False},
}

def _fallback_detection(self, file_path: Path) -> FormatInfo:
    """Fallback detection using file extension."""
    ext = file_path.suffix.lower()
    defaults = EXTENSION_MAP.get(ext, {})

    return FormatInfo(
        format=defaults.get('format', 'Unknown'),
        encoding=defaults.get('encoding', 'Unknown'),
        is_lossless=defaults.get('lossless', False),
        quality_score=0.5,  # Neutral score for unknown
        source="extension"
    )
```

### MP3 VBR Classification
```python
MP3_VBR_RANGES = {
    'V0': (220, 260),  # Average bitrate ranges
    'V1': (190, 230),
    'V2': (170, 210),
    'V3': (150, 190),
    'V4': (130, 170),
    'V5': (110, 150),
}

def _classify_mp3_vbr(self, audio) -> str:
    """Classify MP3 VBR encoding."""
    if not hasattr(audio.info, 'bitrate'):
        return 'VBR'

    bitrate = audio.info.bitrate

    for vbr_class, (min_br, max_br) in MP3_VBR_RANGES.items():
        if min_br <= bitrate <= max_br:
            return vbr_class

    return f'VBR{bitrate}'
```

### Quality Scoring
```python
def _calculate_quality(self, audio) -> float:
    """Calculate relative quality score (0.0-1.0)."""
    if self._is_lossless(audio):
        return 1.0

    if not hasattr(audio.info, 'bitrate'):
        return 0.5

    bitrate = audio.info.bitrate

    # Quality thresholds
    if bitrate >= 320:
        return 0.9
    elif bitrate >= 256:
        return 0.8
    elif bitrate >= 192:
        return 0.7
    elif bitrate >= 128:
        return 0.6
    else:
        return 0.4
```

## Format-Specific Logic

### MP3 Detection
```python
def _handle_mp3(self, audio) -> dict:
    """Handle MP3-specific detection."""
    info = {
        'format': 'MP3',
        'is_lossless': False
    }

    if hasattr(audio.info, 'bitrate_mode'):
        if audio.info.bitrate_mode == BitrateMode.VBR:
            info['encoding'] = self._classify_mp3_vbr(audio)
            info['is_vbr'] = True
        else:
            info['encoding'] = f'CBR{audio.info.bitrate}'
            info['is_vbr'] = False

    return info
```

### FLAC Detection
```python
def _handle_flac(self, audio) -> dict:
    """Handle FLAC-specific detection."""
    return {
        'format': 'FLAC',
        'encoding': 'Lossless',
        'is_lossless': True,
        'is_vbr': False
    }
```

### AAC Detection
```python
def _handle_aac(self, audio) -> dict:
    """Handle AAC-specific detection."""
    info = {
        'format': 'AAC',
        'is_lossless': False,
        'is_vbr': True  # AAC typically VBR
    }

    # Detect AAC profile if available
    if hasattr(audio, 'tags') and audio.tags:
        profile = audio.tags.get('profile', [''])[0]
        if 'HE' in profile:
            info['encoding'] = 'AAC-HE'
        else:
            info['encoding'] = 'AAC-LC'
    else:
        info['encoding'] = 'AAC'

    return info
```

## Error Handling

### Missing Mutagen
```python
def __init__(self, require_mutagen: bool = False):
    self.has_mutagen = False
    try:
        import mutagen
        self.has_mutagen = True
    except ImportError:
        if require_mutagen:
            raise ImportError("Mutagen required but not available")
```

### Corrupted Files
```python
def detect_format(self, file_path: Path) -> FormatInfo:
    """Detect format with error handling."""
    if not file_path.exists():
        return FormatInfo(source="error")

    if not file_path.is_file():
        return FormatInfo(source="error")

    try:
        if self.has_mutagen:
            return self._detect_mutagen(file_path)
        else:
            return self._fallback_detection(file_path)
    except Exception as e:
        # Log error but continue with fallback
        logger.warning(f"Format detection failed for {file_path}: {e}")
        return self._fallback_detection(file_path)
```

## Performance Optimization

### File Size Limits
```python
MAX_SCAN_SIZE = 50 * 1024 * 1024  # 50MB limit

def _should_scan_file(self, file_path: Path) -> bool:
    """Check if file should be scanned."""
    try:
        size = file_path.stat().st_size
        return size <= MAX_SCAN_SIZE
    except (OSError, PermissionError):
        return False
```

### Caching
```python
from functools import lru_cache

@lru_cache(maxsize=1024)
def _detect_cached(self, file_path_str: str) -> FormatInfo:
    """Cached format detection."""
    return self._detect_mutagen(Path(file_path_str))
```

## Usage Examples

### Basic Detection
```python
detector = FormatDetector()

# Detect format of audiobook file
file_path = Path("audiobook.m4b")
format_info = detector.detect_format(file_path)

print(f"Format: {format_info.format}")
print(f"Encoding: {format_info.encoding}")
print(f"Quality: {format_info.quality_score:.1f}")
```

### Batch Processing
```python
def analyze_library(library_path: Path) -> List[FormatInfo]:
    """Analyze entire audiobook library."""
    detector = FormatDetector()
    results = []

    for audio_file in library_path.glob("**/*.m4b"):
        format_info = detector.detect_format(audio_file)
        results.append(format_info)

    return results
```

### Quality Assessment
```python
def assess_quality(format_info: FormatInfo) -> str:
    """Provide human-readable quality assessment."""
    if format_info.is_lossless:
        return "Excellent (Lossless)"
    elif format_info.quality_score >= 0.8:
        return "Very Good"
    elif format_info.quality_score >= 0.6:
        return "Good"
    else:
        return "Fair"
```

## Testing Strategy

### Unit Tests
- Test all supported formats
- Verify VBR classification accuracy
- Check graceful degradation
- Validate quality scoring

### Integration Tests
```python
def test_real_files():
    """Test with actual audio files."""
    detector = FormatDetector()

    # Test various real files
    test_files = [
        ("sample.mp3", "MP3"),
        ("sample.flac", "FLAC"),
        ("sample.m4b", "AAC"),
    ]

    for file_path, expected_format in test_files:
        info = detector.detect_format(Path(file_path))
        assert info.format == expected_format
```

## Dependencies

### Required
- **Python 3.8+**: pathlib, dataclasses

### Optional
- **mutagen >= 1.47**: Primary audio metadata library
- **python-magic**: Enhanced MIME type detection

### Installation
```bash
# Full functionality
pip install mutagen

# Minimal functionality (extension-based)
# No additional dependencies needed
```
