# 7.5 — Audiobook Metadata Field Merger (precedence + union)

> Dedicated spec for **audiobook** metadata merging in `mk_torrent`. This doc is referenced by §7.5 of the main Blueprint.

---

## Purpose

Combine multiple metadata sources (path → embedded tags → Audnexus API) into a **single, deterministic** record used by validators and tracker mappers (e.g., RED). The merger is **declarative** (per-field precedence) and **smart for lists** (stable union with de‑duplication).

---

## Inputs: normalized per-source payloads

Each source module returns a small dict with a required `"_src"` key (one of `"path" | "embedded" | "api"`).

### a) `sources/pathinfo.py` → from folder/filename

Source example:

```
How a Realist Hero Rebuilt the Kingdom - vol_03 (2023) (Dojyomaru) {ASIN.B0C8ZW5N6Y}
```

Normalized:

```python
path_md = {
    "_src": "path",
    "title": "How a Realist Hero Rebuilt the Kingdom: Volume 3",  # optional; processor can compose from series/volume too
    "series": "How a Realist Hero Rebuilt the Kingdom",
    "volume": "03",                  # zero‑padded
    "year": 2023,
    "author": "Dojyomaru",
    "asin": "B0C8ZW5N6Y",
}
```

> If `pathinfo` prefers to only emit `series/volume`, the processor can compose `title`. The merger only picks winners.

### b) `sources/embedded.py` → from Mutagen/MediaInfo

Mapping tips:

* `Title` → `title`
* `Album_Performer` or `Performer` → `author`
* `Composer` → `narrator`
* `Recorded_Date` → `year` (int)
* `Duration` (seconds) → `duration_sec` (int)
* `Genre` (semicolon/commas) → `genres: list[str]`
* `Description` or `Comment` → `description` (HTML allowed)
* Cover exists, but no URL in file → leave `artwork_url` empty

Normalized:

```python
embedded_md = {
    "_src": "embedded",
    "title": "How a Realist Hero Rebuilt the Kingdom: Volume 3",
    "album": "How a Realist Hero Rebuilt the Kingdom: Volume 3: How a Realist Hero Rebuilt the Kingdom, Book 3",
    "author": "Dojyomaru",
    "narrator": "BJ Harrison",
    "year": 2023,
    "duration_sec": 31509,
    "format": "AAC",
    "encoding": "LC",
    "genres": ["Science Fiction & Fantasy", "Comics & Graphic Novels"],
    "description": "<p>The Battle Continues!</p> ...",
    "publisher": "Tantor Audio",
}
```

### c) `sources/audnexus.py` → from Audnexus API

Mapping tips:

* `title` → `title`, `authors[0].name` → `author`, `narrators[0].name` → `narrator`
* `publisherName` → `publisher`, `releaseDate` → `year`
* `runtimeLengthMin` × 60 → `duration_sec`
* `genres[].name` → `genres`
* `image` → `artwork_url`, `isbn` → `isbn`
* `seriesPrimary.name` → `series`, `seriesPrimary.position` → `volume` (pad later)
* `summary` (fallback `description`) → `description` (HTML)

Normalized:

```python
api_md = {
    "_src": "api",
    "title": "How a Realist Hero Rebuilt the Kingdom: Volume 3",
    "subtitle": "How a Realist Hero Rebuilt the Kingdom, Book 3",
    "author": "Dojyomaru",
    "narrator": "BJ Harrison",
    "publisher": "Tantor Audio",
    "year": 2023,
    "duration_sec": 524 * 60,  # 31440
    "genres": ["Science Fiction & Fantasy", "Fantasy", "Epic", "Historical"],
    "artwork_url": "https://m.media-amazon.com/images/I/81IpsoA4EqL.jpg",
    "isbn": "9798765080221",
    "series": "How a Realist Hero Rebuilt the Kingdom",
    "volume": "3",
    "description": "<p>The Battle Continues!</p> ...",
}
```

---

## Default precedence (audiobooks)

```python
DEFAULT_PRECEDENCE = {
    # scalar fields
    "title":        ["api", "embedded", "path"],
    "author":       ["api", "embedded", "path"],
    "series":       ["path", "api", "embedded"],
    "volume":       ["path", "api", "embedded"],
    "year":         ["api", "embedded", "path"],
    "narrator":     ["api", "embedded", "path"],
    "publisher":    ["api", "embedded", "path"],
    "asin":         ["path", "api", "embedded"],
    "isbn":         ["api", "embedded", "path"],
    "duration_sec": ["embedded", "api", "path"],  # embedded precise seconds > API minutes

    # list fields (union with precedence)
    "genres":       ["api", "embedded", "path"],
    "tags":         ["api", "embedded", "path"],

    # presentational
    "description":  ["api", "embedded", "path"],
    "artwork_url":  ["api", "embedded", "path"],
    "album":        ["embedded", "api", "path"],
}

LIST_FIELDS = {"genres", "tags"}  # extendable (e.g., "chapters")
```

**Rationales**

* `duration_sec`: embedded has exact seconds; API is minute‑granular
* `series/volume`: the path is already tracker‑compliant → prefer `path`
* `genres`: canonical API genres, then embedded extras (de‑dup)
* `album`: embedded often carries rich album strings; processor defaults `album = title` if absent

---

## Implementation — `services/merge.py`

```python
from __future__ import annotations
from typing import Any, Dict, List, Iterable, Optional

Scalar = Any
Metadata = Dict[str, Any]
Candidates = List[Metadata]

DEFAULT_PRECEDENCE: Dict[str, List[str]] = {
    "title":        ["api", "embedded", "path"],
    "author":       ["api", "embedded", "path"],
    "series":       ["path", "api", "embedded"],
    "volume":       ["path", "api", "embedded"],
    "year":         ["api", "embedded", "path"],
    "narrator":     ["api", "embedded", "path"],
    "publisher":    ["api", "embedded", "path"],
    "asin":         ["path", "api", "embedded"],
    "isbn":         ["api", "embedded", "path"],
    "duration_sec": ["embedded", "api", "path"],
    "genres":       ["api", "embedded", "path"],
    "tags":         ["api", "embedded", "path"],
    "description":  ["api", "embedded", "path"],
    "artwork_url":  ["api", "embedded", "path"],
    "album":        ["embedded", "api", "path"],
}

LIST_FIELDS = {"genres", "tags"}


def _is_meaningful(value: Any) -> bool:
    if value is None:
        return False
    if isinstance(value, str):
        return value.strip() != ""
    if isinstance(value, (list, tuple, set, dict)):
        return len(value) > 0
    return True


def _values_for_field(candidates: Candidates, field: str, src: str) -> Optional[Any]:
    for c in candidates:
        if c.get("_src") == src and field in c and _is_meaningful(c[field]):
            return c[field]
    return None


def _dedupe_preserve_order(items: Iterable[str]) -> List[str]:
    seen = set()
    out: List[str] = []
    for it in items:
        k = it.strip()
        if k and k.lower() not in seen:
            seen.add(k.lower())
            out.append(k)
    return out


class FieldMerger:
    """
    Declarative precedence-based merger.
    - Scalars: pick first meaningful value by precedence.
    - Lists: start with highest-precedence list, then append unique items
      from lower-precedence lists (case-insensitive de-dupe; stable order).
    """
    def __init__(self, precedence: Optional[Dict[str, List[str]]] = None):
        self.precedence = precedence or DEFAULT_PRECEDENCE

    def merge(self, candidates: Candidates) -> Metadata:
        fields = set(self.precedence.keys())
        for c in candidates:
            fields.update(k for k in c.keys() if k != "_src")

        merged: Metadata = {}
        for field in fields:
            order = self.precedence.get(field, ["api", "embedded", "path"])
            if field in LIST_FIELDS:
                merged[field] = self._merge_list_field(candidates, field, order)
            else:
                val = self._pick_scalar_field(candidates, field, order)
                if _is_meaningful(val):
                    merged[field] = val
        return merged

    def _pick_scalar_field(self, candidates: Candidates, field: str, order: List[str]) -> Optional[Scalar]:
        for src in order:
            val = _values_for_field(candidates, field, src)
            if _is_meaningful(val):
                return val
        return None

    def _merge_list_field(self, candidates: Candidates, field: str, order: List[str]) -> List[Any]:
        out: List[Any] = []
        for src in order:
            val = _values_for_field(candidates, field, src)
            if not _is_meaningful(val):
                continue
            if isinstance(val, str):
                parts = [p.strip() for p in val.replace(";", ",").split(",") if p.strip()]
            else:
                parts = list(val)
            out.extend(parts)
        return _dedupe_preserve_order(out)
```

---

## Expected merged output (for the running example)

```python
{
  "title": "How a Realist Hero Rebuilt the Kingdom: Volume 3",
  "author": "Dojyomaru",
  "series": "How a Realist Hero Rebuilt the Kingdom",
  "volume": "03",              # path wins; zero‑pad may be enforced in enhance()
  "year": 2023,
  "narrator": "BJ Harrison",
  "publisher": "Tantor Audio",
  "asin": "B0C8ZW5N6Y",
  "isbn": "9798765080221",
  "duration_sec": 31509,        # embedded precise seconds
  "genres": [
    "Science Fiction & Fantasy",
    "Fantasy",
    "Epic",
    "Historical",
    "Comics & Graphic Novels",
  ],
  "description": "<p>The Battle Continues!</p> ...",
  "artwork_url": "https://m.media-amazon.com/images/I/81IpsoA4EqL.jpg",
  "album": "How a Realist Hero Rebuilt the Kingdom: Volume 3: How a Realist Hero Rebuilt the Kingdom, Book 3",
}
```

---

## Tests (pytest)

`tests/unit/core/metadata/services/test_merge.py`

```python
import pytest
from src.mk_torrent.core.metadata.services.merge import FieldMerger, DEFAULT_PRECEDENCE

@pytest.fixture
def path_md():
    return {
        "_src": "path",
        "title": "How a Realist Hero Rebuilt the Kingdom: Volume 3",
        "series": "How a Realist Hero Rebuilt the Kingdom",
        "volume": "03",
        "year": 2023,
        "author": "Dojyomaru",
        "asin": "B0C8ZW5N6Y",
    }

@pytest.fixture
def embedded_md():
    return {
        "_src": "embedded",
        "title": "How a Realist Hero Rebuilt the Kingdom: Volume 3",
        "album": "How a Realist Hero Rebuilt the Kingdom: Volume 3: How a Realist Hero Rebuilt the Kingdom, Book 3",
        "author": "Dojyomaru",
        "narrator": "BJ Harrison",
        "year": 2023,
        "duration_sec": 31509,
        "format": "AAC",
        "encoding": "LC",
        "genres": ["Science Fiction & Fantasy", "Comics & Graphic Novels"],
        "description": "<p>The Battle Continues!</p> ...",
        "publisher": "Tantor Audio",
    }

@pytest.fixture
def api_md():
    return {
        "_src": "api",
        "title": "How a Realist Hero Rebuilt the Kingdom: Volume 3",
        "subtitle": "How a Realist Hero Rebuilt the Kingdom, Book 3",
        "author": "Dojyomaru",
        "narrator": "BJ Harrison",
        "publisher": "Tantor Audio",
        "year": 2023,
        "duration_sec": 524 * 60,
        "genres": ["Science Fiction & Fantasy", "Fantasy", "Epic", "Historical"],
        "artwork_url": "https://m.media-amazon.com/images/I/81IpsoA4EqL.jpg",
        "isbn": "9798765080221",
        "series": "How a Realist Hero Rebuilt the Kingdom",
        "volume": "3",
        "description": "<p>The Battle Continues!</p> ...",
    }


def test_merge_realist_hero_example(path_md, embedded_md, api_md):
    merger = FieldMerger(DEFAULT_PRECEDENCE)
    out = merger.merge([path_md, embedded_md, api_md])

    assert out["title"].startswith("How a Realist Hero Rebuilt the Kingdom")
    assert out["author"] == "Dojyomaru"
    assert out["series"] == "How a Realist Hero Rebuilt the Kingdom"
    assert out["volume"] in ("03", "3")
    assert out["year"] == 2023
    assert out["narrator"] == "BJ Harrison"
    assert out["publisher"] == "Tantor Audio"
    assert out["asin"] == "B0C8ZW5N6Y"
    assert out["isbn"] == "9798765080221"

    assert out["duration_sec"] == 31509

    assert out["genres"][:4] == [
        "Science Fiction & Fantasy", "Fantasy", "Epic", "Historical"
    ]
    assert "Comics & Graphic Novels" in out["genres"]

    assert "The Battle Continues" in out["description"]
    assert out["artwork_url"].startswith("https://m.media-amazon.com/")
    assert "Book 3" in out.get("album", "")


def test_merge_handles_missing_fields(path_md, embedded_md, api_md):
    api_md2 = dict(api_md)
    api_md2.pop("genres")
    api_md2.pop("narrator")

    merger = FieldMerger()
    out = merger.merge([path_md, embedded_md, api_md2])

    assert out["narrator"] == "BJ Harrison"
    assert out["genres"] == [
        "Science Fiction & Fantasy", "Comics & Graphic Novels"
    ]
```

---

## Integration in the pipeline

1. Processor gathers candidates: `[path_md, embedded_md, api_md]`.
2. `FieldMerger.merge(candidates)` → `merged` dict.
3. Run normalizers (HTML → plaintext, zero‑pad volume, `album = title` fallback).
4. Validators check completeness; mappers (e.g., RED) serialize for upload.

---

## Config & overrides

* Precedence is injected at `FieldMerger(precedence=...)` or loaded from `metadata.yaml`.
* To union other lists (e.g., `chapters`), add the field name to `LIST_FIELDS` and precedence key to `DEFAULT_PRECEDENCE`.
* Empty strings / whitespace are ignored. Case-insensitive de‑dup for list items.

---

## Edge cases & notes

* **Conflicts:** first meaningful source by precedence wins (no warnings by default; emit logs in processor if desired).
* **Missing fields:** skipped gracefully; downstream normalizers may backfill (e.g., `album`).
* **Duration choice:** embedded preferred to avoid minute rounding.
* **Series position:** merger doesn’t pad; do that in `enhance()` so it’s consistent across inputs.

---

## Future extensions

* Add `chapters` list union with structural de‑dup (title + start offset) when both embedded menu and API chapters exist.
* Add per-field conflict telemetry for debugging (which source won and why).
