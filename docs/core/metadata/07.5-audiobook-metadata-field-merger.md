# 7.5 — Audiobook Metadata Field Merger (precedence + union)

> Dedicated spec for **audiobook** metadata merging in `mk_torrent`. This doc is referenced by §7.5 of the main Blueprint.

> **IMPLEMENTATION STATUS**: ✅ **COMPLETE** - Implemented as `merge_audiobook.py` service with sophisticated three-source merging

---

## Purpose

Combine multiple metadata sources (path → embedded tags → Audnexus API) into a **single, deterministic** record used by validators an## Edge cases & notes

* **Conflicts:** first meaningful source by precedence wins (no warnings by default; emit logs in processor if desired)
* **Missing fields:** skipped gracefully; downstream normalizers may backfill (e.g., `album`)
* **Duration choice:** embedded preferred to avoid minute rounding from API
* **Series position:** merger doesn't pad; do that in `enhance()` so it's consistent across inputsker mappers (e.g., RED). The merger is **declarative** (per-field precedence) and **smart for lists** (stable union with de‑duplication).

## Architecture Update

**Module Location**: `src/mk_torrent/core/metadata/services/merge_audiobook.py`

**Integration**: Used by `AudiobookProcessor` to intelligently merge results from:

* API source (Audnexus)
* Embedded metadata source
* Path/filename parsing source

**Future Expansion**: When adding music/video support, create separate `merge_music.py` and `merge_video.py` modules with media-specific precedence rules.

updated: 2025-09-06T19:09:40-05:00
---

## Inputs: normalized per-source payloads

Each source module returns a small dict with a required `"_src"` key (one of `"path" | "embedded" | "api"`).

### a) `sources/pathinfo.py` → from folder/filename

Source example:

```
How a Realist Hero Rebuilt the Kingdom - vol_03 (2023) (Dojyomaru) {ASIN.B0C8ZW5N6Y}
```

Normalized:

```python
path_md = {
    "_src": "path",
    "title": "How a Realist Hero Rebuilt the Kingdom: Volume 3",  # optional; processor can compose from series/volume too
    "series": "How a Realist Hero Rebuilt the Kingdom",
    "volume": "03",                  # zero‑padded
    "year": 2023,
    "author": "Dojyomaru",
    "asin": "B0C8ZW5N6Y",
}
```

> If `pathinfo` prefers to only emit `series/volume`, the processor can compose `title`. The merger only picks winners.

### b) `sources/embedded.py` → technical file details only

**NEW APPROACH**: Focus on reliable technical information rather than inconsistent tag metadata.

Mapping tips:

* **Technical Details (reliable)**:
  * Duration in precise seconds → `duration_sec` (int)
  * File size in bytes → `file_size_bytes` (int)
  * Audio codec/format → `codec`, `format_name`
  * Bitrate, sample rate, channels → `bitrate`, `sample_rate`, `channels`
  * Embedded cover presence → `has_embedded_cover` (bool)
  * Chapter count → `chapter_count` (int), `has_chapters` (bool)

* **Avoid extracting**: Title, author, narrator, series, description, etc.
  (these are unreliable and handled better by path info + Audnexus API)

Normalized:

```python
embedded_md = {
    "_src": "embedded",
    "duration_sec": 31509,           # Precise seconds from audio stream
    "file_size_bytes": 367296512,   # Exact file size
    "file_size_mb": 350.19,         # Human-readable size
    "format_name": "mov,mp4,m4a,3gp,3g2,mj2",
    "format_long_name": "QuickTime / MOV",
    "codec": "aac",                 # Audio codec
    "codec_long_name": "AAC (Advanced Audio Coding)",
    "profile": "LC",                # AAC profile
    "bitrate": 125588,              # Bits per second
    "bitrate_mode": "CBR",          # NEW: CBR/VBR detection
    "bitrate_variance": 1.2,        # NEW: Variance percentage
    "sample_rate": 44100,           # Hz
    "channels": 2,                  # Stereo
    "channel_layout": "stereo",
    "has_embedded_cover": True,     # Cover art present
    "cover_codec": "mjpeg",
    "cover_dimensions": {"width": 2400, "height": 2400},
    "chapter_count": 7,             # Number of chapters
    "has_chapters": True,
    "chapters": [                   # Detailed chapter timing
        {
            "title": "Intro Credits",
            "start_time": 0.0,
            "end_time": 20.618980,
            "duration": 20.618980
        },
        # ... more chapters
    ],
    "source": "ffprobe"            # or "mutagen" or "basic_file_info"
}
```

```

### c) `sources/audnexus.py` → from Audnexus API

Mapping tips:

* `title` → `title`, `authors[0].name` → `author`, `narrators[0].name` → `narrator`
* `publisherName` → `publisher`, `releaseDate` → `year`
* `runtimeLengthMin` × 60 → `duration_sec`
* `genres[].name` → `genres`
* `image` → `artwork_url`, `isbn` → `isbn`
* `seriesPrimary.name` → `series`, `seriesPrimary.position` → `volume` (pad later)
* `summary` (fallback `description`) → `description` (HTML)

Normalized:

```python
api_md = {
    "_src": "api",
    "title": "How a Realist Hero Rebuilt the Kingdom: Volume 3",
    "subtitle": "How a Realist Hero Rebuilt the Kingdom, Book 3",
    "author": "Dojyomaru",
    "narrator": "BJ Harrison",
    "publisher": "Tantor Audio",
    "year": 2023,
    "duration_sec": 524 * 60,  # 31440
    "genres": ["Science Fiction & Fantasy", "Fantasy", "Epic", "Historical"],
    "artwork_url": "https://m.media-amazon.com/images/I/81IpsoA4EqL.jpg",
    "isbn": "9798765080221",
    "series": "How a Realist Hero Rebuilt the Kingdom",
    "volume": "3",
    "description": "<p>The Battle Continues!</p> ...",
}
```

---

## Default precedence (audiobooks)

```python
DEFAULT_PRECEDENCE = {
    # Descriptive fields (path + API only, embedded unreliable)
    "title":        ["api", "path"],           # Skip embedded titles
    "author":       ["api", "path"],           # Skip embedded authors
    "series":       ["path", "api"],           # Path wins for compliance
    "volume":       ["path", "api"],           # Path wins for compliance
    "year":         ["api", "path"],           # API more accurate
    "narrator":     ["api"],                   # API only (embedded unreliable)
    "publisher":    ["api"],                   # API only (embedded unreliable)
    "asin":         ["path", "api"],           # Path for tracker compliance
    "isbn":         ["api"],                   # API only
    "description":  ["api"],                   # API only (embedded often poor quality)
    "artwork_url":  ["api"],                   # API only (embedded is file presence, not URL)

    # Technical fields (embedded wins - most accurate)
    "duration_sec": ["embedded", "api"],       # Embedded precise seconds > API minutes
    "file_size_bytes": ["embedded"],           # Only embedded has this
    "file_size_mb":    ["embedded"],           # Only embedded has this
    "bitrate":         ["embedded"],           # Only embedded has this
    "bitrate_mode":    ["embedded"],           # NEW: CBR/VBR detection
    "bitrate_variance": ["embedded"],          # NEW: Variance percentage
    "sample_rate":     ["embedded"],           # Only embedded has this
    "channels":        ["embedded"],           # Only embedded has this
    "codec":           ["embedded"],           # Only embedded has this
    "format_name":     ["embedded"],           # Only embedded has this
    "has_embedded_cover": ["embedded"],        # Only embedded has this
    "chapter_count":   ["embedded", "api"],    # Embedded count > API chapters
    "has_chapters":    ["embedded", "api"],    # Embedded detection > API

    # List fields (API primary, embedded technical details)
    "genres":       ["api"],                   # API only (embedded often poor)
    "tags":         ["api"],                   # API only (embedded often poor)
    "chapters":     ["api", "embedded"],       # API structured data > embedded timing
}

# Technical fields are scalars, not lists
LIST_FIELDS = {"genres", "tags", "chapters"}
```

**Rationales**

* **Enhanced embedded focus**: Now includes CBR/VBR detection and improved chapter analysis
* `duration_sec`: embedded has exact seconds; API is minute-granular
* **Descriptive metadata**: API + path only; embedded tags too inconsistent across encoders
* **Technical data**: embedded is authoritative source for file properties
* **CBR/VBR analysis**: embedded exclusive - mathematical bitrate variance calculation
* `chapters`: API provides better structured data, embedded provides precise timing and count
* **File properties**: Only embedded source can provide bitrate, codec, file size, encoding analysis

---

## Implementation — `services/merge_audiobook.py`

```python
from __future__ import annotations
from typing import Any, Dict, List, Iterable, Optional

Scalar = Any
Metadata = Dict[str, Any]
Candidates = List[Metadata]

DEFAULT_PRECEDENCE: Dict[str, List[str]] = {
    "title":        ["api", "embedded", "path"],
    "author":       ["api", "embedded", "path"],
    "series":       ["path", "api", "embedded"],
    "volume":       ["path", "api", "embedded"],
    "year":         ["api", "embedded", "path"],
    "narrator":     ["api", "embedded", "path"],
    "publisher":    ["api", "embedded", "path"],
    "asin":         ["path", "api", "embedded"],
    "isbn":         ["api", "embedded", "path"],
    "duration_sec": ["embedded", "api", "path"],
    "genres":       ["api", "embedded", "path"],
    "tags":         ["api", "embedded", "path"],
    "description":  ["api", "embedded", "path"],
    "artwork_url":  ["api", "embedded", "path"],
    "album":        ["embedded", "api", "path"],
}

LIST_FIELDS = {"genres", "tags"}


def _is_meaningful(value: Any) -> bool:
    if value is None:
        return False
    if isinstance(value, str):
        return value.strip() != ""
    if isinstance(value, (list, tuple, set, dict)):
        return len(value) > 0
    return True


def _values_for_field(candidates: Candidates, field: str, src: str) -> Optional[Any]:
    for c in candidates:
        if c.get("_src") == src and field in c and _is_meaningful(c[field]):
            return c[field]
    return None


def _dedupe_preserve_order(items: Iterable[str]) -> List[str]:
    seen = set()
    out: List[str] = []
    for it in items:
        k = it.strip()
        if k and k.lower() not in seen:
            seen.add(k.lower())
            out.append(k)
    return out


class FieldMerger:
    """
    Declarative precedence-based merger.
    - Scalars: pick first meaningful value by precedence.
    - Lists: start with highest-precedence list, then append unique items
      from lower-precedence lists (case-insensitive de-dupe; stable order).
    """
    def __init__(self, precedence: Optional[Dict[str, List[str]]] = None):
        self.precedence = precedence or DEFAULT_PRECEDENCE

    def merge(self, candidates: Candidates) -> Metadata:
        fields = set(self.precedence.keys())
        for c in candidates:
            fields.update(k for k in c.keys() if k != "_src")

        merged: Metadata = {}
        for field in fields:
            order = self.precedence.get(field, ["api", "embedded", "path"])
            if field in LIST_FIELDS:
                merged[field] = self._merge_list_field(candidates, field, order)
            else:
                val = self._pick_scalar_field(candidates, field, order)
                if _is_meaningful(val):
                    merged[field] = val
        return merged

    def _pick_scalar_field(self, candidates: Candidates, field: str, order: List[str]) -> Optional[Scalar]:
        for src in order:
            val = _values_for_field(candidates, field, src)
            if _is_meaningful(val):
                return val
        return None

    def _merge_list_field(self, candidates: Candidates, field: str, order: List[str]) -> List[Any]:
        out: List[Any] = []
        for src in order:
            val = _values_for_field(candidates, field, src)
            if not _is_meaningful(val):
                continue
            if isinstance(val, str):
                parts = [p.strip() for p in val.replace(";", ",").split(",") if p.strip()]
            else:
                parts = list(val)
            out.extend(parts)
        return _dedupe_preserve_order(out)
```

---

## Expected merged output (for the running example)

```python
{
  # Descriptive metadata (API + path)
  "title": "How a Realist Hero Rebuilt the Kingdom: Volume 3",  # API wins
  "author": "Dojyomaru",                                       # API wins
  "series": "How a Realist Hero Rebuilt the Kingdom",         # path wins (compliance)
  "volume": "03",                                              # path wins (zero-padded)
  "year": 2023,                                               # API wins
  "narrator": "BJ Harrison",                                  # API only
  "publisher": "Tantor Audio",                               # API only
  "asin": "B0C8ZW5N6Y",                                      # path wins (compliance)
  "isbn": "9798765080221",                                   # API only
  "description": "<p>The Battle Continues!</p> ...",        # API only
  "artwork_url": "https://m.media-amazon.com/images/I/81IpsoA4EqL.jpg",  # API only
  "genres": ["Science Fiction & Fantasy", "Fantasy", "Epic", "Historical"],  # API only

  # Technical metadata (embedded)
  "duration_sec": 31509,                                     # embedded precise seconds
  "file_size_bytes": 367296512,                             # embedded only
  "file_size_mb": 350.19,                                   # embedded only
  "bitrate": 125588,                                        # embedded only
  "sample_rate": 44100,                                     # embedded only
  "channels": 2,                                            # embedded only
  "codec": "aac",                                           # embedded only
  "format_name": "mov,mp4,m4a,3gp,3g2,mj2",              # embedded only
  "has_embedded_cover": True,                               # embedded only
  "cover_dimensions": {"width": 2400, "height": 2400},     # embedded only
  "chapter_count": 7,                                       # embedded count
  "has_chapters": True,                                     # embedded detection

  # Chapter data (API structured + embedded timing)
  "chapters": [                                             # API structured data preferred
    # API chapters with standardized timing vs embedded raw timing
  ]
}
```

---

## Tests (pytest)

`tests/unit/core/metadata/services/test_merge_audiobook.py`

```python
import pytest
from src.mk_torrent.core.metadata.services.merge_audiobook import FieldMerger, DEFAULT_PRECEDENCE

@pytest.fixture
def path_md():
    return {
        "_src": "path",
        "title": "How a Realist Hero Rebuilt the Kingdom: Volume 3",
        "series": "How a Realist Hero Rebuilt the Kingdom",
        "volume": "03",
        "year": 2023,
        "author": "Dojyomaru",
        "asin": "B0C8ZW5N6Y",
    }

@pytest.fixture
def embedded_md():
    return {
        "_src": "embedded",
        "title": "How a Realist Hero Rebuilt the Kingdom: Volume 3",
        "album": "How a Realist Hero Rebuilt the Kingdom: Volume 3: How a Realist Hero Rebuilt the Kingdom, Book 3",
        "author": "Dojyomaru",
        "narrator": "BJ Harrison",
        "year": 2023,
        "duration_sec": 31509,
        "format": "AAC",
        "encoding": "LC",
        "genres": ["Science Fiction & Fantasy", "Comics & Graphic Novels"],
        "description": "<p>The Battle Continues!</p> ...",
        "publisher": "Tantor Audio",
    }

@pytest.fixture
def api_md():
    return {
        "_src": "api",
        "title": "How a Realist Hero Rebuilt the Kingdom: Volume 3",
        "subtitle": "How a Realist Hero Rebuilt the Kingdom, Book 3",
        "author": "Dojyomaru",
        "narrator": "BJ Harrison",
        "publisher": "Tantor Audio",
        "year": 2023,
        "duration_sec": 524 * 60,
        "genres": ["Science Fiction & Fantasy", "Fantasy", "Epic", "Historical"],
        "artwork_url": "https://m.media-amazon.com/images/I/81IpsoA4EqL.jpg",
        "isbn": "9798765080221",
        "series": "How a Realist Hero Rebuilt the Kingdom",
        "volume": "3",
        "description": "<p>The Battle Continues!</p> ...",
    }


def test_merge_realist_hero_example(path_md, embedded_md, api_md):
    merger = FieldMerger(DEFAULT_PRECEDENCE)
    out = merger.merge([path_md, embedded_md, api_md])

    assert out["title"].startswith("How a Realist Hero Rebuilt the Kingdom")
    assert out["author"] == "Dojyomaru"
    assert out["series"] == "How a Realist Hero Rebuilt the Kingdom"
    assert out["volume"] in ("03", "3")
    assert out["year"] == 2023
    assert out["narrator"] == "BJ Harrison"
    assert out["publisher"] == "Tantor Audio"
    assert out["asin"] == "B0C8ZW5N6Y"
    assert out["isbn"] == "9798765080221"

    assert out["duration_sec"] == 31509

    assert out["genres"][:4] == [
        "Science Fiction & Fantasy", "Fantasy", "Epic", "Historical"
    ]
    assert "Comics & Graphic Novels" in out["genres"]

    assert "The Battle Continues" in out["description"]
    assert out["artwork_url"].startswith("https://m.media-amazon.com/")
    assert "Book 3" in out.get("album", "")


def test_merge_handles_missing_fields(path_md, embedded_md, api_md):
    api_md2 = dict(api_md)
    api_md2.pop("genres")
    api_md2.pop("narrator")

    merger = FieldMerger()
    out = merger.merge([path_md, embedded_md, api_md2])

    assert out["narrator"] == "BJ Harrison"
    assert out["genres"] == [
        "Science Fiction & Fantasy", "Comics & Graphic Novels"
    ]
```

---

## Integration in the pipeline

**UPDATED IMPLEMENTATION**:

1. `AudiobookProcessor.extract()` collects metadata from three sources:
   * `AudnexusSource.extract()` → API metadata with `_src: "api"`
   * `EmbeddedSource.extract()` → Technical metadata with `_src: "embedded"`
   * `PathInfoSource.extract()` → Filename parsing with `_src: "path"`

2. `merge_audiobook.merge_metadata(candidates)` → intelligently merged dict using declarative precedence rules

3. Result passed to `processor.enhance()` for field normalization (HTML cleanup, zero-pad volume, `album = title` fallback)

4. Validators check completeness; mappers (e.g., RED) serialize for upload

**Key Architectural Change**: Processor now orchestrates extraction and delegates intelligent merging to the specialized service, eliminating primitive `.update()` logic.

---

## Config & overrides

* Precedence is injected at `FieldMerger(precedence=...)` or uses `DEFAULT_PRECEDENCE` from `merge_audiobook.py`
* To union other lists (e.g., `chapters`), add the field name to `LIST_FIELDS` and precedence key to `DEFAULT_PRECEDENCE`
* Empty strings / whitespace are ignored. Case-insensitive de‑dup for list items

---

## Edge cases & notes

* **Conflicts:** first meaningful source by precedence wins (no warnings by default; emit logs in processor if desired).
* **Missing fields:** skipped gracefully; downstream normalizers may backfill (e.g., `album`).
* **Duration choice:** embedded preferred to avoid minute rounding.
* **Series position:** merger doesn’t pad; do that in `enhance()` so it’s consistent across inputs.

---

---

## Future extensions

* **Music Support**: Create `merge_music.py` with music-specific precedence rules (e.g., embedded tags might be more reliable than API for music)
* **Video Support**: Create `merge_video.py` with video-specific rules (e.g., API data often more comprehensive for movies/TV)
* Add `chapters` list union with structural de‑dup (title + start offset) when both embedded menu and API chapters exist

---

## Changelog

### 2025-09-03 - Three-Source Strategy Implementation

* **BREAKING**: Embedded source refactored from descriptive to technical-only approach
* **Updated**: DEFAULT_PRECEDENCE with technical vs descriptive field separation
* **Enhanced**: Support for new technical fields (file_size_bytes, bitrate, codec, etc.)
* **See**: [CHANGELOG.md](./CHANGELOG.md#2025-09-03---three-source-strategy-implementation) for detailed implementation notes

````
